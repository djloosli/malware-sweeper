# Script to find instances of various MITRE ATT&CK techniques including encryption, base64 encoding, websites, IP addresses, persistence mechanisms, XOR operations, PowerShell/script execution, sandbox detection, privilege escalation, buffer overflow attacks, email usage, and more.
# @author djloosli
# @category: Malware
# @keybinding 
# @menupath
# @toolbar
#
# School project intended for using Ghidra to skim binaries to find potential areas of interest
# Can easily be expanded to add more functionality

# Import necessary Ghidra modules
from ghidra.program.model.symbol import SymbolUtilities
from ghidra.program.model.data import StringDataType
from ghidra.program.model.listing import FunctionManager
from ghidra.program.model.symbol import SymbolType
from ghidra.program.model.listing import CodeUnit
import re  # Import the regular expressions module
import base64  # Import the base64 module

# Initialize counters for summary
encryption_count = 0
base64_count = 0
url_ip_count = 0
api_call_count = 0
persistence_count = 0
dll_side_loading_count = 0
xor_count = 0
powershell_count = 0
sandbox_detection_count = 0
privilege_escalation_count = 0
buffer_overflow_count = 0
email_count = 0

# These settings can be adjusted as needed. Useful when binaries have over 3000 XOR operations
# Maximum number of instances to display for each type in Ghidra Console
MAX_DISPLAY = 20
# Limit the display to 100 characters in the console. Some scans print entire data blocks
DISPLAY_LIMIT = 100  

# Execution Techniques
# Searches for use of any types of encryption, password hashing, or other hashing methods
def scan_for_encryption_functions(currentProgram):
    global encryption_count
    encryption_functions = [
        "AES_encrypt", "AES_decrypt", "RSA_public_encrypt", "RSA_private_decrypt", "SHA256",
        "SHA1", "MD5", "Blowfish_encrypt", "Blowfish_decrypt", "DES_encrypt", "DES_decrypt",
        "RC4", "RC5", "Twofish", "Serpent", "bcrypt", "PBKDF2", "scrypt", "Argon2",
        "SHA3", "Whirlpool", "Tiger", "RIPEMD160", "HMAC", "HKDF", "SHA-", "SHA", "SHA512"
    ]
    function_manager = currentProgram.getFunctionManager()
    functions = function_manager.getFunctions(True)  # True to iterate forward through the functions

    for function in functions:
        for enc_function in encryption_functions:
            if enc_function in function.getName():
                if encryption_count < MAX_DISPLAY:
                    print("|~|~|~|~| Found encryption function: ", function.getName(), " at address: ", function.getEntryPoint())
                encryption_count += 1
                break  # Found a match, no need to check the rest of the list for this function

# Not functioning correctly as still getting lots of false positives after multiple iterations
def scan_for_base64_usage(currentProgram):
    global base64_count
    base64_functions = ["Base64Encode", "Base64Decode", "base64_encode", "base64_decode"]
    symbol_table = currentProgram.getSymbolTable()
    symbols = symbol_table.getSymbols(True)  # True to include dynamic symbols

    for symbol in symbols:
        if symbol.getSymbolType() == SymbolType.FUNCTION and symbol.getName() in base64_functions:
            if base64_count < MAX_DISPLAY:
                print("|~|~|~|~| Found base64 function: ", symbol.getName(), " at address: ", symbol.getAddress())
            base64_count += 1

    # Refined pattern to detect base64 strings with more specificity
    listing = currentProgram.getListing()
    data = listing.getDefinedData(True)

    base64_pattern = re.compile(r'\b(?:[A-Za-z0-9+/]{4}){4,}(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?\b')

    for datum in data:
        dataType = datum.getDataType()
        if isinstance(dataType, StringDataType):
            string_value = str(datum.getValue())
            matches = base64_pattern.findall(string_value)
            for match in matches:
                if len(match) > 16 and len(match) % 4 == 0:  # Ensure the match is at least 16 characters long and a multiple of 4
                    try:
                        if base64.b64encode(base64.b64decode(match)) == bytes(match, 'ascii'):
                            if base64_count < MAX_DISPLAY:
                                print("|~|~|~|~| Found potential base64-encoded string: ", match[:DISPLAY_LIMIT], " at address: ", datum.getAddress())
                            base64_count += 1
                    except Exception:
                        continue

# Scans for PowerShell being used and any scripts it may try and run
def scan_for_powershell_usage(currentProgram):
    global powershell_count
    powershell_strings = [
        "powershell.exe",
        "-enc",
        "-ep bypass",
        "-noni"
    ]
    listing = currentProgram.getListing()
    data = listing.getDefinedData(True)

    for datum in data:
        dataType = datum.getDataType()
        if isinstance(dataType, StringDataType):
            string_value = str(datum.getValue())
            for powershell_string in powershell_strings:
                if powershell_string in string_value:
                    if powershell_count < MAX_DISPLAY:
                        print("|~|~|~|~| Found PowerShell usage: ", string_value[:DISPLAY_LIMIT], " at address: ", datum.getAddress())
                    powershell_count += 1

# Persistence Techniques
def scan_for_persistence_mechanisms(currentProgram):
    global persistence_count
    persistence_strings = [
        r"\\Microsoft\\Windows\\PLA\\Server Manager Performance Monitor",
        r"\\Microsoft\\Windows\\Ras\\ManagerMobility",
        r"\\Microsoft\\Windows\\WDI\\SrvSetupResults",
        r"\\Microsoft\\Windows\\WDI\\USOShared",
        r"schtasks /Create /SC ONLOgon /TN WindowsUpdateCheck /TR",
        r"timeSetEvent",
        r"ITaskService::Connect",
        r"ITaskScheduler::AddWorkItem",
        r"ITaskFolder::RegisterTask",
        r"TaskScheduler",
        r"Schedule.Task"
    ]
    listing = currentProgram.getListing()
    data = listing.getDefinedData(True)

    for datum in data:
        dataType = datum.getDataType()
        if isinstance(dataType, StringDataType):
            string_value = str(datum.getValue())
            for persistence_string in persistence_strings:
                if re.search(persistence_string, string_value):
                    if persistence_count < MAX_DISPLAY:
                        print("|~|~|~|~| Found persistence mechanism: ", string_value[:DISPLAY_LIMIT], " at address: ", datum.getAddress())
                    persistence_count += 1
           
# Function uses regex to compare DLLs and source images to find any strings that match the pattern                 
def scan_for_dll_side_loading(currentProgram):
    global dll_side_loading_count
    # List of commonly exploited DLLs
    dll_side_loading_indicators = [
        "wmiclnt.dll", "WmiApRpl.dll", "wmiprov.dll", "wmiutils.dll", "wbemcomn.dll", "wbemprox.dll", 
        "WMINet_Utils.dll", "wbemsvc.dll", "fastprox.dll", "comctl32.dll", "kernel32.dll", "user32.dll", 
        "advapi32.dll", "ntdll.dll", "shell32.dll", "gdi32.dll", "ole32.dll", "shlwapi.dll", "urlmon.dll", 
        "msvcrt.dll", "ws2_32.dll", "crypt32.dll", "wininet.dll"
    ]
    # Source images used for DLL side-loading attacks
    source_images = [
        "WmiPrvSe.exe", "WmiAPsrv.exe", "svchost.exe", "DeviceCensus.exe", "CompatTelRunner.exe", 
        "sdiagnhost.exe", "SIHClient.exe", "ngentask.exe", "taskhostw.exe", "MoUsoCoreWorker.exe", 
        "WMIADAP.exe", "Sysmon.exe", "unsecapp.exe", "logman.exe", "systeminfo.exe", "nvcontainer.exe", 
        "WMIC.exe", "explorer.exe", "opera_autoupdate.exe", "MsMpEng.exe", "thor64.exe", "thor.exe", 
        "notepad.exe", "wordpad.exe", "iexplore.exe", "chrome.exe", "firefox.exe", "svchost.exe", 
        "msiexec.exe", "services.exe", "lsass.exe", "csrss.exe", "explorer.exe", "taskmgr.exe", 
        "powershell.exe", "cmd.exe"
    ]

    listing = currentProgram.getListing()
    data = listing.getDefinedData(True)

    dll_pattern = re.compile(r"\b(?:wmiclnt\.dll|WmiApRpl\.dll|wmiprov\.dll|wmiutils\.dll|wbemcomn\.dll|wbemprox\.dll|WMINet_Utils\.dll|wbemsvc\.dll|fastprox\.dll|comctl32\.dll|kernel32\.dll|user32\.dll|advapi32\.dll|ntdll\.dll|shell32\.dll|gdi32\.dll|ole32\.dll|shlwapi\.dll|urlmon\.dll|msvcrt\.dll|ws2_32\.dll|crypt32\.dll|wininet\.dll)\b", re.IGNORECASE)
    source_pattern = re.compile(r"\b(?:WmiPrvSe\.exe|WmiAPsrv\.exe|svchost\.exe|DeviceCensus\.exe|CompatTelRunner\.exe|sdiagnhost\.exe|SIHClient\.exe|ngentask\.exe|taskhostw\.exe|MoUsoCoreWorker\.exe|WMIADAP\.exe|Sysmon\.exe|unsecapp\.exe|logman\.exe|systeminfo\.exe|nvcontainer\.exe|WMIC\.exe|explorer\.exe|opera_autoupdate\.exe|MsMpEng\.exe|thor64\.exe|thor\.exe|notepad\.exe|wordpad\.exe|iexplore\.exe|chrome\.exe|firefox\.exe|svchost\.exe|msiexec\.exe|services\.exe|lsass\.exe|csrss\.exe|explorer\.exe|taskmgr\.exe|powershell\.exe|cmd\.exe)\b", re.IGNORECASE)

    for datum in data:
        dataType = datum.getDataType()
        if isinstance(dataType, StringDataType):
            string_value = str(datum.getValue())
            if dll_pattern.search(string_value) or source_pattern.search(string_value):
                if dll_side_loading_count < MAX_DISPLAY:
                    print("|~|~|~|~| Found potential DLL side-loading string: ", string_value[:DISPLAY_LIMIT], " at address: ", datum.getAddress())
                dll_side_loading_count += 1


# Privilege Escalation Techniques
def scan_for_privilege_escalation(currentProgram):
    global privilege_escalation_count
    privilege_escalation_indicators = [
        "SeDebugPrivilege", "SeTcbPrivilege", "SeBackupPrivilege", "SeRestorePrivilege", "SeShutdownPrivilege",
        "SeRemoteShutdownPrivilege", "SeTakeOwnershipPrivilege", "SeLoadDriverPrivilege", "SeSystemProfilePrivilege",
        "SeSystemtimePrivilege", "SeProfileSingleProcessPrivilege", "SeIncreaseBasePriorityPrivilege", "SeCreatePagefilePrivilege",
        "SeIncreaseQuotaPrivilege", "SeUndockPrivilege", "SeManageVolumePrivilege", "SeImpersonatePrivilege", "SeCreateGlobalPrivilege",
        "SeEnableDelegationPrivilege", "SeAuditPrivilege", "SeAssignPrimaryTokenPrivilege", "SeLockMemoryPrivilege"
    ]
    listing = currentProgram.getListing()
    data = listing.getDefinedData(True)

    for datum in data:
        dataType = datum.getDataType()
        if isinstance(dataType, StringDataType):
            string_value = str(datum.getValue())
            for indicator in privilege_escalation_indicators:
                if indicator in string_value:
                    if privilege_escalation_count < MAX_DISPLAY:
                        print("|~|~|~|~| Found privilege escalation indicator: ", string_value[:DISPLAY_LIMIT], " at address: ", datum.getAddress())
                    privilege_escalation_count += 1

# Defense Evasion Techniques
# Usefulness of this function is debateable and can be commented out if necessary. Useful for getting an overall idea of what is going on.
def scan_for_xor_operations(currentProgram):
    global xor_count
    listing = currentProgram.getListing()
    instructions = listing.getInstructions(True)

    for instr in instructions:
        if instr.getMnemonicString() == "XOR":
            if xor_count < MAX_DISPLAY:
                print("|~|~|~|~| Found XOR operation at address: ", instr.getAddress())
            xor_count += 1
            
# Scans for sandbox detection as well as debugging APIs
def scan_for_sandbox_detection(currentProgram):
    global sandbox_detection_count
    sandbox_indicators = [
        "SbieDll.dll", "dbghelp.dll", "api_log", "dir_watch", "pstorec", "vmcheck.dll", "syscall_check",
        "wireshark", "packetmon", "vmware", "vbox", "sandboxie", "snort", "procmon",
        "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "NtQueryInformationProcess",
        "OutputDebugString", "FindWindow", "FindWindowEx", "ZwQueryInformationProcess"
    ]
    listing = currentProgram.getListing()
    data = listing.getDefinedData(True)

    for datum in data:
        dataType = datum.getDataType()
        if isinstance(dataType, StringDataType):
            string_value = str(datum.getValue())
            for indicator in sandbox_indicators:
                if indicator in string_value:
                    if sandbox_detection_count < MAX_DISPLAY:
                        print("|~|~|~|~| Found sandbox/debugging detection indicator: ", string_value[:DISPLAY_LIMIT], " at address: ", datum.getAddress())
                    sandbox_detection_count += 1

# Discovery Techniques
# Searching for websites or IP addresses
def scan_for_suspicious_strings(currentProgram):
    global url_ip_count
    listing = currentProgram.getListing()
    data = listing.getDefinedData(True)
    
    # Regular expressions for detecting URLs and IP addresses
    url_pattern = re.compile(r"http[s]?://[^\s]+")
    ip_pattern = re.compile(r"(\d{1,3}\.){3}\d{1,3}")

    for datum in data:
        dataType = datum.getDataType()
        if isinstance(dataType, StringDataType):
            string_value = str(datum.getValue())
            if url_pattern.search(string_value):
                if url_ip_count < MAX_DISPLAY:
                    print("|~|~|~|~| Found URL: ", string_value[:DISPLAY_LIMIT], " at address: ", datum.getAddress())
                url_ip_count += 1
            if ip_pattern.search(string_value):
                if url_ip_count < MAX_DISPLAY:
                    print("|~|~|~|~| Found IP address: ", string_value[:DISPLAY_LIMIT], " at address: ", datum.getAddress())
                url_ip_count += 1

# Scans for various APIs such as network, service, injection, or file system
def scan_for_suspicious_api_calls(currentProgram):
    global api_call_count
    suspicious_api_calls = [
        "CreateProcess", "VirtualAlloc", "WriteProcessMemory", "LoadLibrary",
        "CreateService", "StartService", "OpenSCManager", "OpenService",
        "ControlService", "DeleteService",
        "CreateRemoteThread", "WriteProcessMemory", "SetWindowsHookEx",
        "QueueUserAPC", "NtQueueApcThread", "send", "recv", "connect",
        "bind", "WSASocket", "InternetOpen",
        "InternetConnect", "HttpOpenRequest", "HttpSendRequest"
    ]
    function_manager = currentProgram.getFunctionManager()  # Access the function manager
    functions = function_manager.getFunctions(True)  # Iterate over all functions

    for function in functions:
        if function.getName() in suspicious_api_calls:
            if api_call_count < MAX_DISPLAY:
                print("|~|~|~|~| Found suspicious API call: ", function.getName(), " at address: ", function.getEntryPoint())
            api_call_count += 1

# Collection Techniques
# Email Usage Detection
def scan_for_email_usage(currentProgram):
    global email_count
    email_strings = [
        "smtp", "mail", "pop3", "imap", "email", "mail from", "rcpt to"
    ]
    email_functions = [
        "SMTPClient", "SendMail", "MailMessage", "SmtpClient", "MailAddress"
    ]
    listing = currentProgram.getListing()
    data = listing.getDefinedData(True)
    
    for datum in data:
        dataType = datum.getDataType()
        if isinstance(dataType, StringDataType):
            string_value = str(datum.getValue())
            for email_string in email_strings:
                if email_string in string_value.lower():
                    if email_count < MAX_DISPLAY:
                        print("|~|~|~|~| Found email-related string: ", string_value[:DISPLAY_LIMIT], " at address: ", datum.getAddress())
                    email_count += 1

    function_manager = currentProgram.getFunctionManager()
    functions = function_manager.getFunctions(True)
    
    for function in functions:
        if function.getName() in email_functions:
            if email_count < MAX_DISPLAY:
                print("|~|~|~|~| Found email-related function: ", function.getName(), " at address: ", function.getEntryPoint())
            email_count += 1

# Impact Techniques
# Scans for various functions that can be used for buffer overflow attacks
def scan_for_buffer_overflow_functions(currentProgram):
    global buffer_overflow_count
    buffer_overflow_functions = [
        "strcpy", "strncpy", "sprintf", "vsprintf", "gets", "strcat", "lstrcpyA", "lstrcpynA", "lstrcatA", "printf", "scanf",
        "_free", "_memmove", "_memcpy"
    ]
    function_manager = currentProgram.getFunctionManager()
    functions = function_manager.getFunctions(True)

    for function in functions:
        if function.getName() in buffer_overflow_functions:
            if buffer_overflow_count < MAX_DISPLAY:
                print("|~|~|~|~| Found potential buffer overflow function: ", function.getName(), " at address: ", function.getEntryPoint())
            buffer_overflow_count += 1

# Main function to perform all scans
def main():
    # Reset counters
    global encryption_count, base64_count, url_ip_count, api_call_count
    global persistence_count, xor_count, powershell_count, sandbox_detection_count
    global privilege_escalation_count, buffer_overflow_count, email_count, dll_side_loading_count
    
    encryption_count = 0
    base64_count = 0
    url_ip_count = 0
    api_call_count = 0
    persistence_count = 0
    xor_count = 0
    powershell_count = 0
    sandbox_detection_count = 0
    privilege_escalation_count = 0
    buffer_overflow_count = 0
    email_count = 0
    dll_side_loading_count = 0
    
    # Comment out different functions if wanting to only scan for certain objects
    # Be sure to adjust MAX_DISPLAY or DISPLAY_LIMIT
    currentProgram = getCurrentProgram()
    scan_for_encryption_functions(currentProgram)
    scan_for_base64_usage(currentProgram)
    scan_for_suspicious_strings(currentProgram)
    scan_for_suspicious_api_calls(currentProgram)
    scan_for_persistence_mechanisms(currentProgram)
    scan_for_dll_side_loading(currentProgram)
    scan_for_xor_operations(currentProgram)
    scan_for_powershell_usage(currentProgram)
    scan_for_sandbox_detection(currentProgram)
    scan_for_privilege_escalation(currentProgram)
    scan_for_buffer_overflow_functions(currentProgram)
    scan_for_email_usage(currentProgram)

    # Print summary
    print("\nSummary:")
    print(f"Encryption/Encoding functions found: {encryption_count}")
    print(f"Base64 functions found: {base64_count}")
    print(f"URLs/IP addresses found: {url_ip_count}")
    print(f"Suspicious API calls found: {api_call_count}")
    print(f"Persistence mechanisms found: {persistence_count}")
    print(f"DLL side-loading indicators found: {dll_side_loading_count}")
    print(f"XOR operations found: {xor_count}")
    print(f"PowerShell usage found: {powershell_count}")
    print(f"Sandbox/debugging detection indicators found: {sandbox_detection_count}")
    print(f"Privilege escalation indicators found: {privilege_escalation_count}")
    print(f"Buffer overflow functions found: {buffer_overflow_count}")
    print(f"Email usage found: {email_count}")

# Run the main function
main()
